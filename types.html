<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.3 at Nov 17, 2016 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>javaRuntype: runtime type system for Java - Types</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20161117" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                                      <a href="./" id="bannerLeft">
                                                <img src="images/javaruntype_logo.png" alt="javaRuntype: runtime type system for Java" />
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 17 Nov 2016</span>
                  &nbsp;| <span id="projectVersion">Version: 1.3</span>
                      </div>
            <div class="xright">                    <a href="index.html" title="Main">Main</a>
            |
                        <a href="download.html" title="Download">Download</a>
            |
                        <a href="apidocs/index.html" title="Javadoc">Javadoc</a>
            |
                        <a href="https://github.com/javaruntype/javaruntype" class="externalLink" title="Github Repository">Github Repository</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                <h5>The javaRuntype Project</h5>
                  <ul>
                  <li class="none">
                          <a href="index.html" title="· Main">· Main</a>
            </li>
                  <li class="none">
                          <a href="download.html" title="· Download">· Download</a>
            </li>
                  <li class="none">
                          <a href="maveninfo.html" title="· Maven Info">· Maven Info</a>
            </li>
                  <li class="none">
                          <a href="dependencies.html" title="· Dependencies">· Dependencies</a>
            </li>
                                                                                                            <li class="expanded">
                          <a href="#" title="· Documentation">· Documentation</a>
                    <ul>
                      <li class="none">
            <strong>· Using Types</strong>
          </li>
                      <li class="none">
                          <a href="apidocs/index.html" title="· Javadoc">· Javadoc</a>
            </li>
                      <li class="none">
                          <a href="faq.html" title="· FAQ">· FAQ</a>
            </li>
              </ul>
        </li>
                  <li class="none">
                          <a href="https://github.com/javaruntype/javaruntype" class="externalLink" title="· Github Repository">· Github Repository</a>
            </li>
                  <li class="none">
                          <a href="license.html" title="· License">· License</a>
            </li>
                  <li class="none">
                          <a href="team.html" title="· Team">· Team</a>
            </li>
          </ul>
                                                                                                                                     <a href="https://maven.apache.org" title="Built with Maven 2" class="poweredBy">
        <img class="poweredBy"  alt="Built with Maven 2" src="images/logos/maven-feather.png"     />
      </a>
                       
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Using Types<a name="Using_Types"></a></h2><div class="section"><h3>Type Objects<a name="Type_Objects"></a></h3><p>A Type object can represent any type that we might be able to assign to a variable in Java. Some examples:</p><ul><li><b>java.lang.String</b>&gt;</li><li><b>java.util.Collection&lt;?&gt;</b></li><li><b>java.util.List&lt;java.lang.String&gt;</b></li><li><b>java.util.ArrayList&lt;? extends java.io.Serializable&gt;</b></li><li><b>java.util.HashMap&lt;java.lang.Integer, ? super java.util.List&lt;java.lang.Float[]&gt;&gt;</b></li></ul><p>javaRuntype's Type objects are also serializable, and javaRuntype's engine keeps the number of Type instances low, so that only one object representing a specific Java type exists in memory from a specific classloader at a moment. This allows a comfortable and easy use of big amounts of type objects without worrying too much for memory efficiency.</p><p>All Type objects created with javaRuntype are valid, as the type engine will not allow an invalid type (like &quot;<tt>List&lt;String,Integer&gt;</tt>&quot;) to be created. An exception will be raised if the user tries to obtain a Type object for a java type which is not valid for the current classloader javaRuntype is running in. </p></div><div class="section"><h3>Type API<a name="Type_API"></a></h3><p><tt>Type&lt;T&gt;</tt> objects offer a series of methods:</p><table border="1" class="bodyTable"><tr class="a"><td align="left"><b>Method</b></td><td align="left"><b>Return type</b></td><td align="left"><b>Description</b></td></tr><tr class="b"><td align="left"><tt>getName()</tt></td><td align="left"><tt>String</tt></td><td align="left">Returns the type's name. For instance, &quot;java.util.List&lt;java.lang.String&gt;&quot;.</td></tr><tr class="a"><td align="left"><tt>getSimpleName()</tt></td><td align="left"><tt>String</tt></td><td align="left">Returns the type's name excluding package. For instance, &quot;List&lt;java.lang.String&gt;&quot;.</td></tr><tr class="b"><td align="left"><tt>isAbstract()</tt></td><td align="left"><tt>boolean</tt></td><td align="left">Returns whether the type is abstract or not. For instance, it will return &quot;false&quot; for &quot;AbstractList&lt;String&gt;[]&quot; as, although AbstractList.class is abstract, AbstractList[] is an instantiable class. On the contrary, &quot;AbstractList&lt;String&gt;&quot; would return &quot;true&quot;.</td></tr><tr class="a"><td align="left"><tt>isArray()</tt></td><td align="left"><tt>boolean</tt></td><td align="left">Returns whether the type is an array or not. For instance, it will return &quot;true&quot; for &quot;List&lt;String&gt;[]&quot;.</td></tr><tr class="b"><td align="left"><tt>isAssignableFrom(Type&lt;?&gt; type)</tt></td><td align="left"><tt>boolean</tt></td><td align="left">Returns whether type type is assignable from the type that is passed as a parameter. Assignability is computed in the following terms: a type A is considered to be <i>assignable</i> from another type B if a method declared as receiving a parameter of type A can be called with an object of type B as a parameter.</td></tr><tr class="a"><td align="left"><tt>isInterface()</tt></td><td align="left"><tt>boolean</tt></td><td align="left">Returns whether the type represents an interface or not. For instance, it will return &quot;false&quot; for &quot;List&lt;String&gt;[]&quot; as, although List.class is an interface, List[].class is a instantiable class. On the contrary, &quot;List&lt;String&gt;&quot; would return &quot;true&quot;.</td></tr><tr class="b"><td align="left"><tt>isRaw()</tt></td><td align="left"><tt>boolean</tt></td><td align="left">Returns whether this type would be considered &quot;raw&quot;. A type is raw if the result of calling <tt>getRawEquivalent()</tt> on it is the type itself.</td></tr><tr class="a"><td align="left"><tt>getRawClass()</tt></td><td align="left"><tt>Class&lt;? super T&gt;</tt></td><td align="left">Returns the type's raw equivalent class representation. For instance, if the type is &quot;List&lt;String&gt;[]&quot;, this method will return List[].class (the class representing the raw version of the type), in contrast with <tt>getComponentClass()</tt> which would return List.class (the component class).</td></tr><tr class="b"><td align="left"><tt>getComponentClass()</tt></td><td align="left"><tt>Class&lt;?&gt;</tt></td><td align="left">Returns the type's component class. For instance, it will return List.class for &quot;List&lt;String&gt;[]&quot; (and not List[].class, which would be returned by <tt>getRawClass()</tt>).</td></tr><tr class="a"><td align="left"><tt>getArrayDimensions()</tt></td><td align="left"><tt>int</tt></td><td align="left">Returns the type's array dimensions. For instance, it will return 1 for &quot;List&lt;String&gt;[]&quot;</td></tr><tr class="b"><td align="left"><tt>getTypeParameters()</tt></td><td align="left"><tt>List&lt;TypeParameter&lt;?&gt;&gt;</tt></td><td align="left">Returns the type parameters of the type.</td></tr><tr class="a"><td align="left"><tt>getAllTypesAssignableFromThis()</tt></td><td align="left"><tt>Set&lt;Type&lt;?&gt;&gt;</tt></td><td align="left">Returns a set of the types corresponding to all the interfaces and superclasses that this type implements or extends. For instance, for &quot;List&lt;String&gt;&quot;, this method will return &quot;Collection&lt;String&gt;&quot;, &quot;Iterable&lt;String&gt;&quot; and &quot;Object&quot;.</td></tr><tr class="b"><td align="left"><tt>getRawEquivalent()</tt></td><td align="left"><tt>Type&lt;?&gt;</tt></td><td align="left">Returns a type corresponding with the one on which this method is called, but substituting all its type parameters by &quot;unknown&quot;. For instance: &quot;List&lt;String&gt;&quot; -&gt; &quot;List&lt;?&gt;&quot;.</td></tr><tr class="a"><td align="left"><tt>newInstance()</tt></td><td align="left"><tt>Object</tt></td><td align="left">Creates a new instance of the type. The returned instances are created using the default (no-arg) constructor if this Type does not represent an array. On the contrary, if this Type represents an array, an array object of zero-size dimensions is returned (like &quot;String[0][0][0]&quot;).</td></tr></table></div><div class="section"><h3>Obtaining Type objects<a name="Obtaining_Type_objects"></a></h3><div class="section"><h4>Static constants<a name="Static_constants"></a></h4><p>The <tt>Types</tt> (<tt>org.javaruntype.type.Types</tt>) class offers a comprehensive set of static constants for some of the most used types, for example:</p><table border="1" class="bodyTable"><tr class="a"><td align="left"><b>Java Type</b></td><td align="left"><b>Constant</b></td></tr><tr class="b"><td align="left"><tt>java.lang.String</tt></td><td align="left">Types.STRING</td></tr><tr class="a"><td align="left"><tt>java.lang.Integer</tt></td><td align="left">Types.INTEGER</td></tr><tr class="b"><td align="left"><tt>java.util.Calendar</tt></td><td align="left">Types.CALENDAR</td></tr><tr class="a"><td align="left"><tt>java.io.Serializable</tt></td><td align="left">Types.SERIALIZABLE</td></tr><tr class="b"><td align="left"><tt>java.lang.Long[]</tt></td><td align="left">Types.ARRAY_OF_LONG</td></tr><tr class="a"><td align="left"><tt>java.util.List&lt;?&gt;</tt></td><td align="left">Types.LIST_OF_UNKNOWN</td></tr><tr class="b"><td align="left"><tt>java.util.List&lt;java.lang.String&gt;</tt></td><td align="left">Types.LIST_OF_STRING</td></tr><tr class="a"><td align="left"><tt>java.util.Set&lt;java.util.Calendar&gt;</tt></td><td align="left">Types.SET_OF_CALENDAR</td></tr><tr class="b"><td align="left"><tt>java.util.Map&lt;?,?&gt;</tt></td><td align="left">Types.MAP_OF_UNKNOWN_UNKNOWN</td></tr><tr class="a"><td align="left"><tt>java.util.Map&lt;java.lang.String,java.lang.String&gt;</tt></td><td align="left">Types.MAP_OF_STRING_STRING</td></tr><tr class="b"><td align="left"><tt>java.util.Map&lt;java.lang.String,java.lang.Boolean&gt;</tt></td><td align="left">Types.MAP_OF_STRING_BOOLEAN</td></tr></table><p>...and many more...</p></div><div class="section"><h4>From class<a name="From_class"></a></h4><div class="section"><h5>Raw type from class<a name="Raw_type_from_class"></a></h5><div><pre>    Type&lt;String&gt; strType = Types.forClass(String.class);    
            
    ...
    
    Type&lt;List&lt;?&gt;&gt; listOfUnkType = Types.forClass(List.class);    </pre></div></div><div class="section"><h5>Parameterized type from class<a name="Parameterized_type_from_class"></a></h5><div><pre>    Type&lt;List&lt;String&gt;&gt; listOfStrType = 
        Types.forClass(
            List.class,
            TypeParameters.forType(Types.STRING));
            
    ...
    
    Type&lt;Map&lt;String,? extends Number&gt;&gt; mapOfStrExtNumberType = 
        Types.forClass(
            Map.class,
            TypeParameters.forType(Types.STRING),
            TypeParameters.forExtendsType(Types.NUMBER));</pre></div></div></div><div class="section"><h4>From name<a name="From_name"></a></h4><p>This method of obtaining a Type object requires a cast:</p><div><pre>    Type&lt;String&gt; strType = (Type&lt;String&gt;) Types.forName(&quot;String&quot;);
    
    ...
    
    Type&lt;Map&lt;String,? extends Number&gt;&gt; mapOfStrExtNumberType = 
        (Type&lt;Map&lt;String,? extends Number&gt;&gt;) Types.forName(&quot;Map&lt;String,? extends Number&gt;&quot;);</pre></div><p>When specifying a type by name, classes in the <tt>java.lang</tt>, <tt>java.util</tt>, <tt>java.math</tt> and <tt>java.io</tt> packages do not need their packages to be specified (as you can see in the above examples). </p><p>But:</p><div><pre>    Type&lt;URL&gt; urlType = (Type&lt;URL&gt;) Types.forName(&quot;java.net.URL&quot;);</pre></div></div><div class="section"><h4>From java.lang.reflect.Type objects<a name="From_java.lang.reflect.Type_objects"></a></h4><p>javaRuntype's types can be obtained from <tt>java.lang.reflect.Type</tt> objects as such obtained from methods like <tt>java.lang.reflect.Method#getGenericReturnType()</tt>. </p><div><pre>    
    Method aMethod = SomeClassOfMine.class.getMethod(&quot;toString&quot;);
    java.lang.reflect.Type javaLangReflectType = aMethod.getGenericReturnType();
    
    Type&lt;String&gt; strType = (Type&lt;String&gt;) Types.forJavaLangReflectType(javaLangReflectType);
    </pre></div><p>When obtaining Types this way, variables present in types can be substituted. For example, if you had a <tt>getData()</tt> method defined like:</p><div><pre>
    public class DataClass {
        ...
        public &lt;E&gt; Map&lt;String,List&lt;E&gt;&gt; getData() {
            ...
        }
        ...
    }
    </pre></div><p>You could obtain the <tt>java.lang.reflect.Type</tt> object for the return type with:</p><div><pre>    
    Method getDataMethod = DataClass.class.getMethod(&quot;getData&quot;);
    java.lang.reflect.Type javaLangReflectType = getDataMethod.getGenericReturnType();
    </pre></div><p>But, as javaRuntype's <tt>Type</tt> objects cannot contain unresolved variables (like <tt>E</tt> in <tt>Map&lt;String,List&lt;E&gt;&gt;</tt>), in order to obtain a type we will have to resolve it by creating a variables map linking variable names to Types:</p><div><pre>
    Map&lt;String,Type&lt;?&gt;&gt; variables = new HashMap&lt;String, Type&lt;?&gt;&gt;();
    variables.put(&quot;E&quot;, Types.INTEGER);
    </pre></div><p>...and then use it to obtain our javaRuntype Type, knowing that &quot;<tt>E</tt>&quot; is <tt>Integer</tt>:</p><div><pre>
    // type will be &quot;Map&lt;String,List&lt;Integer&gt;&gt;&quot;
    Type&lt;?&gt; type = Types.forJavaLangReflectType(javaLangReflectType, variables);
</pre></div><p>...or using a cast, if we prefer to be exact:</p><div><pre>  
    Type&lt;Map&lt;String,List&lt;Integer&gt;&gt;&gt; type = 
        (Type&lt;Map&lt;String,List&lt;Integer&gt;&gt;&gt;) Types.forJavaLangReflectType(javaLangReflectType, variables);
  </pre></div></div><div class="section"><h4>Parameterized types from parameters<a name="Parameterized_types_from_parameters"></a></h4><p>The <tt>Types</tt> class can easily create some common parameterized Types from its Type parameters. For example:</p><div><pre>   Type&lt;String[]&gt; strArrType = Types.arrayOf(Types.STRING);</pre></div><p>Available utility methods are:</p><table border="1" class="bodyTable"><tr class="a"><td align="left"><b>Transformation</b></td><td align="left"><b>Factory Method</b></td></tr><tr class="b"><td align="left">T -&gt; T[]</td><td align="left"><tt>Types.arrayOf(Type&lt;T&gt;)</tt></td></tr><tr class="a"><td align="left">T -&gt; Iterable&lt;T&gt;</td><td align="left"><tt>Types.iterableOf(Type&lt;T&gt;)</tt> <tt>Types.iterableOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="b"><td align="left">T -&gt; Class&lt;T&gt;</td><td align="left"><tt>Types.classOf(Type&lt;T&gt;)</tt> <tt>Types.classOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="a"><td align="left">T -&gt; Collection&lt;T&gt;</td><td align="left"><tt>Types.collectionOf(Type&lt;T&gt;)</tt> <tt>Types.collectionOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="b"><td align="left">T -&gt; Comparator&lt;T&gt;</td><td align="left"><tt>Types.comparatorOf(Type&lt;T&gt;)</tt> <tt>Types.comparatorOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="a"><td align="left">T -&gt; Enumeration&lt;T&gt;</td><td align="left"><tt>Types.enumerationOf(Type&lt;T&gt;)</tt> <tt>Types.enumerationOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="b"><td align="left">T -&gt; Iterator&lt;T&gt;</td><td align="left"><tt>Types.iteratorOf(Type&lt;T&gt;)</tt> <tt>Types.iteratorOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="a"><td align="left">T -&gt; List&lt;T&gt;</td><td align="left"><tt>Types.listOf(Type&lt;T&gt;)</tt> <tt>Types.listOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="b"><td align="left">T -&gt; ListIterator&lt;T&gt;</td><td align="left"><tt>Types.listIteratorOf(Type&lt;T&gt;)</tt> <tt>Types.listIteratorOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="a"><td align="left">K,V -&gt; Map&lt;K,V&gt;</td><td align="left"><tt>Types.mapOf(Type&lt;K&gt;,Type&lt;V&gt;)</tt> <tt>Types.mapOf(TypeParameter&lt;K&gt;,TypeParameter&lt;V&gt;)</tt></td></tr><tr class="b"><td align="left">K,V -&gt; Map.Entry&lt;K,V&gt;</td><td align="left"><tt>Types.mapEntryOf(Type&lt;K&gt;,Type&lt;V&gt;)</tt> <tt>Types.mapEntryOf(TypeParameter&lt;K&gt;,TypeParameter&lt;V&gt;)</tt></td></tr><tr class="a"><td align="left">T -&gt; Queue&lt;T&gt;</td><td align="left"><tt>Types.queueOf(Type&lt;T&gt;)</tt> <tt>Types.queueOf(TypeParameter&lt;T&gt;)</tt></td></tr><tr class="b"><td align="left">T -&gt; Set&lt;T&gt;</td><td align="left"><tt>Types.setOf(Type&lt;T&gt;)</tt> <tt>Types.setOf(TypeParameter&lt;T&gt;)</tt></td></tr></table></div><div class="section"><h4>Component types out of parameterized types<a name="Component_types_out_of_parameterized_types"></a></h4><p>The <tt>Types</tt> class can extract types from parameterized types, like: </p><div><pre>   Type&lt;String&gt; strType = Types.arrayComponentOf(Types.ARRAY_OF_STRING);</pre></div><p>Available utility methods are:</p><table border="1" class="bodyTable"><tr class="a"><td align="left"><b>Transformation</b></td><td align="left"><b>Factory Method</b></td></tr><tr class="b"><td align="left">T[] -&gt; T</td><td align="left"><tt>Types.arrayComponentOf(Type&lt;T[]&gt;)</tt></td></tr><tr class="a"><td align="left">Iterable&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.iterableComponentOf(Type&lt;Iterable&lt;T&gt;&gt;)</tt></td></tr><tr class="b"><td align="left">Class&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.classComponentOf(Type&lt;Class&lt;T&gt;&gt;)</tt></td></tr><tr class="a"><td align="left">Collection&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.collectionComponentOf(Type&lt;Collection&lt;T&gt;&gt;)</tt></td></tr><tr class="b"><td align="left">Comparator&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.comparatorComponentOf(Type&lt;Comparator&lt;T&gt;&gt;)</tt></td></tr><tr class="a"><td align="left">Enumeration&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.enumerationComponentOf(Type&lt;Enumeration&lt;T&gt;&gt;)</tt></td></tr><tr class="b"><td align="left">Iterator&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.iteratorComponentOf(Type&lt;Iterator&lt;T&gt;&gt;)</tt></td></tr><tr class="a"><td align="left">List&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.listComponentOf(Type&lt;List&lt;T&gt;&gt;)</tt></td></tr><tr class="b"><td align="left">ListIterator&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.listIteratorComponentOf(Type&lt;ListIterator&lt;T&gt;&gt;)</tt></td></tr><tr class="a"><td align="left">Map&lt;K,V&gt; -&gt; K</td><td align="left"><tt>Types.mapKeyComponentOf(Type&lt;Map&lt;K,V&gt;&gt;)</tt></td></tr><tr class="b"><td align="left">Map&lt;K,V&gt; -&gt; V</td><td align="left"><tt>Types.mapValueComponentOf(Type&lt;Map&lt;K,V&gt;&gt;)</tt></td></tr><tr class="a"><td align="left">Map.Entry&lt;K,V&gt; -&gt; K</td><td align="left"><tt>Types.mapEntryKeyComponentOf(Type&lt;Map.Entry&lt;K,V&gt;&gt;)</tt></td></tr><tr class="b"><td align="left">Map.Entry&lt;K,V&gt; -&gt; V</td><td align="left"><tt>Types.mapEntryValueComponentOf(Type&lt;Map.Entry&lt;K,V&gt;&gt;)</tt></td></tr><tr class="a"><td align="left">Queue&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.queueComponentOf(Type&lt;Queue&lt;T&gt;&gt;)</tt></td></tr><tr class="b"><td align="left">Set&lt;T&gt; -&gt; T</td><td align="left"><tt>Types.setComponentOf(Type&lt;Set&lt;T&gt;&gt;)</tt></td></tr></table></div></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2016
                        <a href="https://www.javaruntype.org">The JAVARUNTYPE team</a>.
            All Rights Reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
